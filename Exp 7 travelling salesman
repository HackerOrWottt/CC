Aim: To solve travelling salesman problem using A* search algorithm. 
Objective:
1. Find the shortest possible route that allows a "salesman" to visit each city exactly once 
and return to the starting city.
2. Evaluate the efficiency and feasibility of the A* algorithm in solving TSP by analyzing 
its performance on smaller datasets, using an admissible heuristic to ensure optimality.
Theory:
The Traveling Salesman Problem (TSP) is a classic optimization problem in which a salesman 
must find the shortest possible route to visit a set of cities exactly once and return to the starting 
city. Solving TSP using the A* search algorithm involves treating the task as a path finding 
problem, where A* can be adapted to explore partial routes and find an optimal tour.
Key Elements of A* for TSP:
1. State Representation: Each state represents a partial tour, showing which cities have 
been visited and the current position.
2. Path Cost (g(n)): This is the cumulative distance of the tour so far from the start city 
to the current city.
3. Heuristic (h(n)): An admissible heuristic, such as the cost of a Minimum Spanning 
Tree (MST) over unvisited cities, estimates the minimal additional distance required to 
complete the tour.
A* Approach for TSP:
A* expands partial tours in increasing order of f(n) = g(n) + h(n), where g(n) is the 
distance travelled so far and h(n) estimates the remaining distance to complete the tour. The 
algorithm stops when it finds a complete tour with the lowest f(n), ensuring the solution is 
optimal if the heuristic is admissible. This approach, while computationally demanding, is a 
useful search method for smaller TSP instances or when heuristics are effectively designed A* Search algorithm 
The A* (A-star) search algorithm is a popular and efficient search algorithm used in path
finding and graph traversal problems. It aims to find the shortest path from a starting point to 
a target by balancing the cost of the path travelled so far and an estimated cost to reach the 
goal. A* is widely used in applications like GPS navigation, puzzle-solving, game 
development, and robotics because it combines elements of Dijkstra's algorithm and Greedy 
Best-First Search, making it both optimal and complete when using an admissible heuristic.
Key Components:
 Path Cost (g(n)): The cost to reach the current state or node from the starting point.
 Heuristic (h(n)): An estimate of the minimum cost required to reach the goal from the 
current state, guiding the algorithm toward the goal efficiently.
 Total Cost (f(n)): The sum of path cost and heuristic, f(n) = g(n) + h(n), determining the 
order in which nodes are expanded.
Working Principle:
A* expands nodes in increasing order of their f(n) values, where nodes closer to the goal or with 
lower cumulative costs are prioritized. This leads to an optimal solution if the heuristic is 
admissible (never overestimates the actual cost) and consistent (satisfies the triangle 
inequality).
Introduction:
The Traveling Salesman Problem (TSP) is a well-known combinatorial optimization 
problem in which a salesman is given a set of cities and must find the shortest possible route 
that allows him to visit each city exactly once and return to the starting point. The goal is to 
minimize the total distance traveled, while ensuring that each city is visited exactly once.
Key Characteristics:
 Input: A set of cities and the distances between every pair of cities (or costs associated 
with traveling between them).  Output: A sequence of cities that represents the shortest possible path that visits all 
cities once and returns to the starting city.
 Objective: Minimize the total travel distance or cost, which is the sum of the distances 
between consecutive cities in the tour.
Advantages:
1. Optimality: The A* algorithm, with an admissible heuristic, guarantees finding the 
optimal solution.
2. Efficiency on Small Graphs: A* performs well on small sets of cities due to its goal-
directed nature, guided by the heuristic function.
3. Flexibility in Heuristic Design: Using MST or other heuristics allows flexibility in 
balancing accuracy and computational efficiency.
Disadvantages:
1. Scalability Issues: A* has exponential time complexity, making it computationally 
expensive for larger TSP instances.
2. Memory Intensive: A* keeps track of all visited states in memory, which can quickly 
grow for larger numbers of cities.
3. Heuristic Dependency: The performance of A* highly depends on the choice of the 
heuristic; poor heuristics can lead to inefficient searches.
Applications:
1. Routing and Logistics: Solving optimal routes for deliveries, like planning routes for 
delivery trucks or drones.
2. Manufacturing: Optimizing paths in robotic manufacturing, where robots move 
between different stations.
3. Circuit Design: Finding optimal paths in circuit layouts, where A* can guide the 
design to minimize wire length and connection costs.
4. Tour Planning: Organizing optimal tour routes in travel industries where each 
location must be visited once.
Implementation:
Steps:
1. State Representation: Each state represents a partial path that includes a subset of 
cities visited and the current position.
2. Heuristic Function (h(n)): We’ll use a heuristic such as the MST cost over the 
unvisited cities to estimate the remaining distance to complete the tour.
3. Cost Function (g(n)): The cost to reach the current city from the start city (sum of the 
distances between cities visited so far). 4. Priority Queue: A priority queue (or min-heap) will be used to prioritize states with 
the lowest total cost f(n) = g(n) + h(n).
Conclusion: 
The A* search algorithm successfully solved the TSP for a small dataset, yielding the optimal path with 
minimal travel cost. This demonstrates that A* with an admissible heuristic, like the Minimum 
Spanning Tree (MST) cost for unvisited cities, can effectively guide the search toward optimal solutions. 
However, due to the exponential growth of possible paths, A* is computationally intensive for larger 
TSP instances. For larger datasets, alternative approaches, such as genetic algorithms or simulated 
annealing, may be more practical, though they do not guarantee optimal solutions.

Code :

import tkinter as tk
from tkinter import messagebox
import matplotlib.pyplot as plt
import heapq
import math
import random

# Utility functions
def euclidean_distance(city1, city2):
    return math.sqrt((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2)

def mst_cost(cities, unvisited):
    visited = [False] * len(cities)
    min_cost = 0
    edges = []  # priority queue for edges as (cost, to_city_index)
    # Start from the first unvisited node
    if not unvisited:
        return 0
    start = next(iter(unvisited))
    heapq.heappush(edges, (0, start))
    while edges:
        cost, city = heapq.heappop(edges)
        if visited[city]:
            continue
        visited[city] = True
        min_cost += cost
        for next_city in unvisited:
            if not visited[next_city]:
                heapq.heappush(edges, (euclidean_distance(cities[city], cities[next_city]), next_city))
    return min_cost

# A* algorithm for TSP
def a_star_tsp(cities):
    open_list = [(0, 0, [0])]  # (cost, current_city, path)
    # We'll store entries as (f_cost, current_city, path)
    while open_list:
        cost, current_city, path = heapq.heappop(open_list)
        if len(path) == len(cities):
            # complete tour: return path and total cost including return to start
            total_cost = cost + euclidean_distance(cities[current_city], cities[path[0]])
            return path + [path[0]], total_cost

        unvisited = set(range(len(cities))) - set(path)
        # heuristic using MST cost over unvisited nodes
        heuristic = mst_cost(cities, unvisited)

        for next_city in unvisited:
            new_cost = cost + euclidean_distance(cities[current_city], cities[next_city])
            # push (f = g + h, next_city, new_path)
            heapq.heappush(open_list, (new_cost + heuristic, next_city, path + [next_city]))
    return None, None

# Plotting function
def plot_path(cities, path, total_cost):
    x, y = zip(*cities)
    plt.plot(x, y, 'o')  # city points
    for i in range(len(path) - 1):
        a = cities[path[i]]
        b = cities[path[i+1]]
        plt.plot([a[0], b[0]], [a[1], b[1]])
    plt.title(f"TSP Solution - Total Distance: {total_cost:.2f}")
    plt.xlabel("X Coordinates")
    plt.ylabel("Y Coordinates")
    plt.show()

# GUI functions
def generate_cities():
    try:
        n = int(city_count_entry.get())
        if n < 2:
            raise ValueError("Please enter a number greater than 1.")
        cities.clear()
        cities.extend([(random.randint(0, 100), random.randint(0, 100)) for _ in range(n)])
        messagebox.showinfo("Success", f"{n} cities generated.")
    except ValueError as e:
        messagebox.showerror("Invalid Input", str(e))

def solve_tsp():
    if len(cities) < 2:
        messagebox.showerror("Error", "Generate cities first!")
        return
    path, total_cost = a_star_tsp(cities)
    if path:
        plot_path(cities, path, total_cost)
    else:
        messagebox.showerror("Error", "No solution found.")

# Main GUI setup
root = tk.Tk()
root.title("Traveling Salesman Problem Solver")

cities = []

tk.Label(root, text="Enter number of cities:").pack()
city_count_entry = tk.Entry(root)
city_count_entry.pack()

tk.Button(root, text="Generate Cities", command=generate_cities).pack()
tk.Button(root, text="Solve TSP", command=solve_tsp).pack()

root.mainloop()
